<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mi Música · Mi 2025 en Música</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>
  <link rel="stylesheet" href="css/style.css">
  <style>
    .album-gallery {
      display: grid;
      grid-template-rows: repeat(5, 100px);
      grid-auto-flow: column;
      grid-auto-columns: 100px;
      gap: 4px;
      overflow-x: auto;
      overflow-y: hidden;
      padding-bottom: 0.5rem;
    }

    .album-item {
      position: relative;
      overflow: hidden;
      cursor: pointer;
    }

    .album-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.2s ease;
    }

    .album-item:hover img {
      transform: scale(1.05);
    }

    .album-item .album-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.9));
      padding: 2rem 0.5rem 0.5rem;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .album-item:hover .album-overlay {
      opacity: 1;
    }

    .album-overlay .album-name {
      font-size: 0.65rem;
      font-weight: 700;
      color: white;
      line-height: 1.2;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .album-overlay .album-artist {
      font-size: 0.55rem;
      color: rgba(255,255,255,0.7);
      margin-top: 2px;
    }

    .album-overlay .album-time {
      font-size: 0.5rem;
      color: rgba(255,255,255,0.5);
      margin-top: 2px;
    }

    .gallery-controls {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .gallery-controls label {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .gallery-controls select {
      font-family: inherit;
      font-size: 0.8rem;
      padding: 0.25rem 0.5rem;
      border: 1px solid var(--border);
      background: var(--bg);
    }

    .gallery-stats {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-left: auto;
    }

    @media (max-width: 600px) {
      .album-gallery {
        grid-template-rows: repeat(5, 80px);
        grid-auto-columns: 80px;
      }
    }

    /* Network Graph */
    #network-container {
      width: 100%;
      height: 500px;
      background: var(--gray-100);
      position: relative;
      overflow: hidden;
    }

    #network-container svg {
      width: 100%;
      height: 100%;
    }

    .network-node {
      cursor: pointer;
    }

    .network-node circle {
      transition: stroke-width 0.2s, stroke 0.2s;
    }

    .network-node:hover circle {
      stroke-width: 4px !important;
      stroke: #000 !important;
    }

    .network-node text {
      font-size: 0.6rem;
      fill: var(--text);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .network-node:hover text,
    .network-node.highlighted text {
      opacity: 1;
    }

    .network-link {
      stroke: var(--gray-400);
      stroke-opacity: 0.6;
      fill: none;
    }

    .network-link.highlighted {
      stroke: var(--text);
      stroke-opacity: 1;
    }

    .network-controls {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .network-controls label {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .network-controls select,
    .network-controls input[type="range"] {
      font-family: inherit;
      font-size: 0.8rem;
    }

    .network-controls select {
      padding: 0.25rem 0.5rem;
      border: 1px solid var(--border);
      background: var(--bg);
    }

    .network-tooltip {
      position: absolute;
      background: var(--text);
      color: var(--bg);
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
      max-width: 200px;
    }

    .network-tooltip.visible {
      opacity: 1;
    }

    .network-tooltip .tooltip-title {
      font-weight: 700;
    }

    .network-tooltip .tooltip-detail {
      font-size: 0.65rem;
      opacity: 0.8;
      margin-top: 2px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Mi 2025 en Música</h1>
    <p class="subtitle">Un año de escuchas en Spotify · Sergio Sánchez · California</p>
  </header>

  <nav>
    <a href="index.html">Resumen</a>
    <a href="heatmaps.html">Heatmaps</a>
    <a href="musica.html" class="active">Mi Música</a>
  </nav>

  <div class="section">
    <div class="section-header">Galería de Álbumes</div>
    <div class="section-content">
      <div class="gallery-controls">
        <label>
          Ordenar por:
          <select id="sort-select">
            <option value="time">Tiempo escuchado</option>
            <option value="plays">Reproducciones</option>
            <option value="name">Nombre</option>
            <option value="artist">Artista</option>
            <option value="release">Fecha de lanzamiento</option>
          </select>
        </label>
        <label>
          Mostrar:
          <select id="limit-select">
            <option value="50">Top 50</option>
            <option value="100" selected>Top 100</option>
            <option value="200">Top 200</option>
            <option value="all">Todos</option>
          </select>
        </label>
        <span class="gallery-stats" id="gallery-stats"></span>
      </div>
      <div class="album-gallery" id="album-gallery"></div>
    </div>
  </div>

  <div class="section">
    <div class="section-header">Red de Colaboraciones</div>
    <div class="section-content">
      <div class="section-note">
        Artistas conectados por tracks en los que colaboraron. Tamaño = tiempo escuchado. Grosor de línea = tiempo de colaboración.
      </div>
      <div class="network-controls">
        <label>
          Mínimo de colaboraciones:
          <select id="network-min-collabs">
            <option value="1">1+</option>
            <option value="2" selected>2+</option>
            <option value="3">3+</option>
            <option value="5">5+</option>
          </select>
        </label>
        <label>
          Mostrar top:
          <select id="network-top-artists">
            <option value="30">30 artistas</option>
            <option value="50" selected>50 artistas</option>
            <option value="75">75 artistas</option>
            <option value="100">100 artistas</option>
          </select>
        </label>
        <span class="gallery-stats" id="network-stats"></span>
      </div>
      <div id="network-container">
        <div class="network-tooltip" id="network-tooltip"></div>
      </div>
    </div>
  </div>

  <div class="methodology">
    <h3>Notas</h3>
    <ul>
      <li>Carátulas obtenidas de la API de Spotify</li>
      <li>Tiempo = suma de milisegundos escuchados de todos los tracks del álbum</li>
      <li>Click en un álbum para abrirlo en Spotify</li>
      <li>Red de colaboraciones: muestra artistas que aparecen juntos en tracks</li>
    </ul>
  </div>

  <footer>
    Creado con datos de Spotify + Claude Code para tacosdedatos
  </footer>

  <script src="js/charts.js"></script>
  <script>
    let albumsData = [];

    async function loadMetadata() {
      const response = await fetch('data/spotify-metadata.json');
      return await response.json();
    }

    function renderAlbumGallery(albums, sortBy = 'time', limit = 100) {
      const container = document.getElementById('album-gallery');
      const stats = document.getElementById('gallery-stats');

      // Sort albums
      let sorted = [...albums];
      switch (sortBy) {
        case 'time':
          sorted.sort((a, b) => (b.ms_played || 0) - (a.ms_played || 0));
          break;
        case 'plays':
          sorted.sort((a, b) => (b.play_count || 0) - (a.play_count || 0));
          break;
        case 'name':
          sorted.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
          break;
        case 'artist':
          sorted.sort((a, b) => (a.artist_names?.[0] || '').localeCompare(b.artist_names?.[0] || ''));
          break;
        case 'release':
          sorted.sort((a, b) => (b.release_date || '').localeCompare(a.release_date || ''));
          break;
      }

      // Apply limit
      const limited = limit === 'all' ? sorted : sorted.slice(0, parseInt(limit));

      // Update stats
      const totalHours = limited.reduce((sum, a) => sum + (a.ms_played || 0), 0) / 3600000;
      stats.textContent = `${limited.length} álbumes · ${totalHours.toFixed(1)}h`;

      // Render gallery
      container.innerHTML = limited.map(album => {
        const image = album.images?.[1]?.url || album.images?.[0]?.url || '';
        const hours = ((album.ms_played || 0) / 3600000).toFixed(1);
        const spotifyUrl = `https://open.spotify.com/album/${album.id}`;

        return `
          <a href="${spotifyUrl}" target="_blank" rel="noopener" class="album-item" title="${album.name} - ${album.artist_names?.[0] || 'Unknown'}">
            <img src="${image}" alt="${album.name}" loading="lazy">
            <div class="album-overlay">
              <div class="album-name">${album.name}</div>
              <div class="album-artist">${album.artist_names?.[0] || ''}</div>
              <div class="album-time">${hours}h</div>
            </div>
          </a>
        `;
      }).join('');
    }

    // Build collaboration network data
    function buildNetworkData(tracks, artists, minCollabs = 2, topArtists = 50) {
      // Create artist lookup with listening stats
      const artistMap = new Map();
      artists.forEach(a => {
        artistMap.set(a.name, {
          id: a.id,
          name: a.name,
          ms_played: a.ms_played || 0,
          popularity: a.popularity || 0,
          genres: a.genres || [],
          image: a.images?.[2]?.url || a.images?.[1]?.url || a.images?.[0]?.url || null
        });
      });

      // Find collaborations
      const edges = new Map();
      tracks.forEach(track => {
        const trackArtists = track.artist_names || [];
        if (trackArtists.length > 1) {
          // Create edges between all pairs
          for (let i = 0; i < trackArtists.length; i++) {
            for (let j = i + 1; j < trackArtists.length; j++) {
              const a1 = trackArtists[i];
              const a2 = trackArtists[j];
              const key = [a1, a2].sort().join('|||');

              if (!edges.has(key)) {
                edges.set(key, { source: a1, target: a2, weight: 0, tracks: [] });
              }
              edges.get(key).weight += track.ms_played || 0;
              edges.get(key).tracks.push(track.name);
            }
          }
        }
      });

      // Filter edges by minimum collaborations
      const filteredEdges = Array.from(edges.values())
        .filter(e => e.tracks.length >= minCollabs);

      // Get artists involved in filtered edges
      const involvedArtists = new Set();
      filteredEdges.forEach(e => {
        involvedArtists.add(e.source);
        involvedArtists.add(e.target);
      });

      // Get top artists by listening time that are involved in collabs
      const nodes = Array.from(involvedArtists)
        .map(name => artistMap.get(name) || { name, ms_played: 0 })
        .filter(a => a.ms_played > 0)
        .sort((a, b) => b.ms_played - a.ms_played)
        .slice(0, topArtists);

      const nodeNames = new Set(nodes.map(n => n.name));

      // Filter edges to only include nodes in our set
      const finalEdges = filteredEdges.filter(e =>
        nodeNames.has(e.source) && nodeNames.has(e.target)
      );

      return { nodes, edges: finalEdges };
    }

    // Render network graph
    let simulation = null;

    function renderNetworkGraph(tracks, artists, minCollabs = 2, topArtists = 50) {
      const container = document.getElementById('network-container');
      const stats = document.getElementById('network-stats');
      const tooltip = document.getElementById('network-tooltip');

      // Clear previous
      container.querySelectorAll('svg').forEach(s => s.remove());
      if (simulation) simulation.stop();

      const { nodes, edges } = buildNetworkData(tracks, artists, minCollabs, topArtists);

      stats.textContent = `${nodes.length} artistas · ${edges.length} colaboraciones`;

      if (nodes.length === 0) {
        container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">No hay suficientes colaboraciones con estos filtros</div>';
        return;
      }

      const width = container.clientWidth;
      const height = container.clientHeight || 500;

      // Create SVG
      const svg = d3.select(container)
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, width, height]);

      // Create defs for image patterns
      const defs = svg.append('defs');

      nodes.forEach((d, i) => {
        if (d.image) {
          defs.append('pattern')
            .attr('id', `artist-img-${i}`)
            .attr('width', 1)
            .attr('height', 1)
            .append('image')
            .attr('href', d.image)
            .attr('width', 80)
            .attr('height', 80)
            .attr('preserveAspectRatio', 'xMidYMid slice');
        }
      });

      // Scales
      const maxMs = d3.max(nodes, d => d.ms_played);
      const radiusScale = d3.scaleSqrt()
        .domain([0, maxMs])
        .range([4, 30]);

      const maxEdgeWeight = d3.max(edges, d => d.weight);
      const strokeScale = d3.scaleSqrt()
        .domain([0, maxEdgeWeight])
        .range([1, 8]);

      // Create node map for edge references
      const nodeMap = new Map(nodes.map(n => [n.name, n]));

      // Prepare edges with node references
      const links = edges.map(e => ({
        ...e,
        source: nodeMap.get(e.source),
        target: nodeMap.get(e.target)
      })).filter(e => e.source && e.target);

      // Force simulation
      simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.name).distance(50).strength(1))
        .force('charge', d3.forceManyBody().strength(-100))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collision', d3.forceCollide().radius(d => radiusScale(d.ms_played) + 3));

      // Draw links
      const link = svg.append('g')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('class', 'network-link')
        .attr('stroke-width', d => strokeScale(d.weight));

      // Draw nodes
      const node = svg.append('g')
        .selectAll('g')
        .data(nodes)
        .join('g')
        .attr('class', 'network-node')
        .call(d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended));

      // Add index to nodes for pattern reference
      nodes.forEach((d, i) => d.nodeIndex = i);

      node.append('circle')
        .attr('r', d => radiusScale(d.ms_played))
        .attr('fill', d => d.image ? `url(#artist-img-${d.nodeIndex})` : (d.genres?.length > 0 ? '#1a1a1a' : '#737373'))
        .attr('stroke', '#1a1a1a')
        .attr('stroke-width', 2);

      node.append('text')
        .text(d => d.name)
        .attr('dx', d => radiusScale(d.ms_played) + 4)
        .attr('dy', '0.35em');

      // Tooltip and highlighting
      node.on('mouseenter', function(event, d) {
        const hours = (d.ms_played / 3600000).toFixed(1);
        const connectedEdges = links.filter(l => l.source.name === d.name || l.target.name === d.name);
        const collabCount = connectedEdges.length;

        tooltip.innerHTML = `
          <div class="tooltip-title">${d.name}</div>
          <div class="tooltip-detail">${hours}h escuchadas</div>
          <div class="tooltip-detail">${collabCount} colaboraciones</div>
          ${d.genres?.length > 0 ? `<div class="tooltip-detail">${d.genres.slice(0, 2).join(', ')}</div>` : ''}
        `;
        tooltip.classList.add('visible');

        // Highlight connected
        const connectedNames = new Set([d.name]);
        connectedEdges.forEach(e => {
          connectedNames.add(e.source.name);
          connectedNames.add(e.target.name);
        });

        node.classed('highlighted', n => connectedNames.has(n.name));
        link.classed('highlighted', l => l.source.name === d.name || l.target.name === d.name);
      })
      .on('mousemove', function(event) {
        const rect = container.getBoundingClientRect();
        tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
      })
      .on('mouseleave', function() {
        tooltip.classList.remove('visible');
        node.classed('highlighted', false);
        link.classed('highlighted', false);
      });

      // Simulation tick
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        node.attr('transform', d => `translate(${d.x},${d.y})`);
      });

      // Drag functions
      function dragstarted(event) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
      }

      function dragged(event) {
        event.subject.fx = event.x;
        event.subject.fy = event.y;
      }

      function dragended(event) {
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
      }
    }

    async function init() {
      const data = await loadMetadata();
      albumsData = data.albums.filter(a => a.images?.length > 0 && a.ms_played > 0);

      // Initial render - Album gallery
      renderAlbumGallery(albumsData, 'time', 100);

      // Initial render - Network graph
      renderNetworkGraph(data.tracks, data.artists, 2, 50);

      // Setup album gallery controls
      document.getElementById('sort-select').addEventListener('change', (e) => {
        const limit = document.getElementById('limit-select').value;
        renderAlbumGallery(albumsData, e.target.value, limit);
      });

      document.getElementById('limit-select').addEventListener('change', (e) => {
        const sortBy = document.getElementById('sort-select').value;
        renderAlbumGallery(albumsData, sortBy, e.target.value);
      });

      // Setup network controls
      document.getElementById('network-min-collabs').addEventListener('change', (e) => {
        const topArtists = parseInt(document.getElementById('network-top-artists').value);
        renderNetworkGraph(data.tracks, data.artists, parseInt(e.target.value), topArtists);
      });

      document.getElementById('network-top-artists').addEventListener('change', (e) => {
        const minCollabs = parseInt(document.getElementById('network-min-collabs').value);
        renderNetworkGraph(data.tracks, data.artists, minCollabs, parseInt(e.target.value));
      });
    }

    init();
  </script>
</body>
</html>
