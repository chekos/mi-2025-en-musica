<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mi Música · Mi 2025 en Música</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>
  <link rel="stylesheet" href="css/style.css">
  <style>
    .album-gallery {
      display: grid;
      grid-template-rows: repeat(5, 100px);
      grid-auto-flow: column;
      grid-auto-columns: 100px;
      gap: 4px;
      overflow-x: auto;
      overflow-y: hidden;
      padding-bottom: 0.5rem;
    }

    .album-item {
      position: relative;
      overflow: hidden;
      cursor: pointer;
    }

    .album-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.2s ease;
    }

    .album-item:hover img {
      transform: scale(1.05);
    }

    .album-item .album-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.9));
      padding: 2rem 0.5rem 0.5rem;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .album-item:hover .album-overlay {
      opacity: 1;
    }

    .album-overlay .album-name {
      font-size: 0.65rem;
      font-weight: 700;
      color: white;
      line-height: 1.2;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .album-overlay .album-artist {
      font-size: 0.55rem;
      color: rgba(255,255,255,0.7);
      margin-top: 2px;
    }

    .album-overlay .album-time {
      font-size: 0.5rem;
      color: rgba(255,255,255,0.5);
      margin-top: 2px;
    }

    .gallery-controls {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .gallery-controls label {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .gallery-controls select {
      font-family: inherit;
      font-size: 0.8rem;
      padding: 0.25rem 0.5rem;
      border: 1px solid var(--border);
      background: var(--bg);
    }

    .gallery-stats {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-left: auto;
    }

    @media (max-width: 600px) {
      .album-gallery {
        grid-template-rows: repeat(5, 80px);
        grid-auto-columns: 80px;
      }
    }

    /* Network Graph */
    #network-container {
      width: 100%;
      height: 500px;
      background: var(--gray-100);
      position: relative;
      overflow: hidden;
    }

    #network-container svg {
      width: 100%;
      height: 100%;
    }

    .network-node {
      cursor: pointer;
    }

    .network-node circle {
      transition: stroke-width 0.2s, stroke 0.2s;
    }

    .network-node:hover circle {
      stroke-width: 4px !important;
      stroke: #000 !important;
    }

    .network-node text {
      font-size: 0.6rem;
      fill: var(--text);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .network-node:hover text,
    .network-node.highlighted text {
      opacity: 1;
    }

    .network-link {
      stroke: var(--gray-400);
      stroke-opacity: 0.6;
      fill: none;
    }

    .network-link.highlighted {
      stroke: var(--text);
      stroke-opacity: 1;
    }

    .network-controls {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .network-controls label {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .network-controls select,
    .network-controls input[type="range"] {
      font-family: inherit;
      font-size: 0.8rem;
    }

    .network-controls select {
      padding: 0.25rem 0.5rem;
      border: 1px solid var(--border);
      background: var(--bg);
    }

    .network-tooltip {
      position: absolute;
      background: var(--text);
      color: var(--bg);
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
      max-width: 200px;
    }

    .network-tooltip.visible {
      opacity: 1;
    }

    .network-tooltip .tooltip-title {
      font-weight: 700;
    }

    .network-tooltip .tooltip-detail {
      font-size: 0.65rem;
      opacity: 0.8;
      margin-top: 2px;
    }

    /* Scatterplot */
    #scatter-container {
      width: 100%;
      height: 450px;
      position: relative;
    }

    #scatter-container svg {
      width: 100%;
      height: 100%;
    }

    .scatter-point {
      cursor: pointer;
      transition: stroke-width 0.2s;
    }

    .scatter-point:hover {
      stroke-width: 3px !important;
    }

    .scatter-quadrant-label {
      font-size: 0.65rem;
      fill: var(--gray-400);
      font-weight: 600;
    }

    .scatter-axis text {
      font-size: 0.7rem;
    }

    .scatter-axis-label {
      font-size: 0.75rem;
      fill: var(--text-muted);
    }
  </style>
</head>
<body>
  <header>
    <h1>Mi 2025 en Música</h1>
    <p class="subtitle">Un año de escuchas en Spotify · Sergio Sánchez · California</p>
  </header>

  <nav>
    <a href="index.html">Resumen</a>
    <a href="heatmaps.html">Heatmaps</a>
    <a href="musica.html" class="active">Mi Música</a>
  </nav>

  <div class="cta-banner">
    <span class="cta-banner-text">¿Quieres aprender a construir algo así? Video y notas en <strong>Tacos de Datos</strong></span>
    <a href="https://tacosdedatos.com" target="_blank" rel="noopener" class="cta-banner-link">Ver tutorial</a>
  </div>

  <div class="narrative">
    <p>
      Esta página es un <strong>mapa de mi identidad musical</strong>. Más de 900 álbumes,
      800 artistas, conexiones entre ellos. Aquí se revelan patrones que ni yo conocía:
      ¿soy más underground o mainstream? ¿Escucho música nueva o clásica?
    </p>
    <p>
      La respuesta corta: <strong>ambas cosas</strong>. Mi biblioteca es un puente entre
      el hip-hop mexicano underground de Tijuana y los clásicos del rock en español.
      Entre los lanzamientos de 2024 y los discos de Café Tacvba de los 90s.
    </p>
    <div class="highlight-song">
      Cada carátula en esta galería representa horas de mi vida. Cada nodo en la red
      es un artista que me acompañó mientras trabajaba, manejaba, o simplemente existía.
      Los datos son fríos, pero la música nunca lo es.
    </div>
  </div>

  <div class="section">
    <div class="section-header">Galería de Álbumes</div>
    <div class="section-content">
      <div class="section-note">
        Cada carátula es una puerta a un momento del año. Ordena por tiempo para ver cuáles me acompañaron más,
        o por fecha de lanzamiento para explorar la arqueología de mis gustos.
      </div>
      <div class="gallery-controls">
        <label>
          Ordenar por:
          <select id="sort-select">
            <option value="time">Tiempo escuchado</option>
            <option value="plays">Reproducciones</option>
            <option value="name">Nombre</option>
            <option value="artist">Artista</option>
            <option value="release">Fecha de lanzamiento</option>
          </select>
        </label>
        <label>
          Mostrar:
          <select id="limit-select">
            <option value="50">Top 50</option>
            <option value="100" selected>Top 100</option>
            <option value="200">Top 200</option>
            <option value="all">Todos</option>
          </select>
        </label>
        <span class="gallery-stats" id="gallery-stats"></span>
      </div>
      <div class="album-gallery" id="album-gallery"></div>
    </div>
  </div>

  <div class="section">
    <div class="section-header">Red de Colaboraciones</div>
    <div class="section-content">
      <div class="section-note">
        El hip-hop vive de las colaboraciones. Esta red revela el <strong>ecosistema musical</strong> que escucho:
        artistas conectados por los tracks donde aparecen juntos. Lo que emerge es un mapa de la escena
        mexicana de rap y sus conexiones. Tamaño del nodo = tiempo escuchado. Grosor de línea = tiempo de colaboración.
      </div>
      <div class="network-controls">
        <label>
          Mínimo de colaboraciones:
          <select id="network-min-collabs">
            <option value="1">1+</option>
            <option value="2" selected>2+</option>
            <option value="3">3+</option>
            <option value="5">5+</option>
          </select>
        </label>
        <label>
          Mostrar top:
          <select id="network-top-artists">
            <option value="30">30 artistas</option>
            <option value="50" selected>50 artistas</option>
            <option value="75">75 artistas</option>
            <option value="100">100 artistas</option>
          </select>
        </label>
        <span class="gallery-stats" id="network-stats"></span>
      </div>
      <div id="network-container">
        <div class="network-tooltip" id="network-tooltip"></div>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="section-header">Underground vs Mainstream</div>
    <div class="section-content">
      <div class="section-note">
        Spotify asigna un puntaje de <strong>popularidad (0-100)</strong> a cada artista basado en reproducciones globales.
        Este scatterplot responde una pregunta que siempre me hago: ¿tengo gustos mainstream o underground?
        La respuesta está en los cuadrantes: mis <strong>favoritos</strong> (arriba) tienden a ser <strong>underground</strong> (izquierda),
        pero también disfruto artistas populares de manera más ocasional.
      </div>
      <div class="network-controls">
        <label>
          Mostrar top:
          <select id="scatter-limit">
            <option value="30">30 artistas</option>
            <option value="50" selected>50 artistas</option>
            <option value="100">100 artistas</option>
            <option value="200">200 artistas</option>
          </select>
        </label>
        <span class="gallery-stats" id="scatter-stats"></span>
      </div>
      <div id="scatter-container">
        <div class="network-tooltip" id="scatter-tooltip"></div>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="section-header">Línea de Tiempo de Lanzamientos</div>
    <div class="section-content">
      <div class="section-note">
        Este histograma cuenta una historia interesante. El pico masivo en <strong>2020-2021</strong> no es coincidencia:
        fueron los años de pandemia, cuando muchos artistas (especialmente en el hip-hop mexicano)
        lanzaron más música que nunca. Yo descubrí esa oleada y nunca dejé de escucharla.
        También se ve mi amor por los <strong>clásicos</strong>: Café Tacvba, Control Machete, y otros
        discos de los 90s y 2000s que siguen en rotación.
      </div>
      <div class="network-controls">
        <label>
          Mostrar por:
          <select id="timeline-metric">
            <option value="count">Cantidad de álbumes</option>
            <option value="time">Tiempo escuchado</option>
          </select>
        </label>
        <span class="gallery-stats" id="timeline-stats"></span>
      </div>
      <div id="timeline-container" style="width: 100%; height: 300px;"></div>
    </div>
  </div>

  <div class="methodology">
    <h3>Notas</h3>
    <ul>
      <li>Carátulas obtenidas de la API de Spotify</li>
      <li>Tiempo = suma de milisegundos escuchados de todos los tracks del álbum</li>
      <li>Click en un álbum para abrirlo en Spotify</li>
      <li>Red de colaboraciones: muestra artistas que aparecen juntos en tracks</li>
      <li>Popularidad: métrica de Spotify (0-100) basada en reproducciones globales recientes</li>
      <li>Release date: fecha de lanzamiento según metadata de Spotify</li>
    </ul>
  </div>

  <footer>
    Creado con datos de Spotify + Claude Code para tacosdedatos
  </footer>

  <script src="js/charts.js"></script>
  <script>
    let albumsData = [];

    async function loadMetadata() {
      const response = await fetch('data/spotify-metadata.json');
      return await response.json();
    }

    function renderAlbumGallery(albums, sortBy = 'time', limit = 100) {
      const container = document.getElementById('album-gallery');
      const stats = document.getElementById('gallery-stats');

      // Sort albums
      let sorted = [...albums];
      switch (sortBy) {
        case 'time':
          sorted.sort((a, b) => (b.ms_played || 0) - (a.ms_played || 0));
          break;
        case 'plays':
          sorted.sort((a, b) => (b.play_count || 0) - (a.play_count || 0));
          break;
        case 'name':
          sorted.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
          break;
        case 'artist':
          sorted.sort((a, b) => (a.artist_names?.[0] || '').localeCompare(b.artist_names?.[0] || ''));
          break;
        case 'release':
          sorted.sort((a, b) => (b.release_date || '').localeCompare(a.release_date || ''));
          break;
      }

      // Apply limit
      const limited = limit === 'all' ? sorted : sorted.slice(0, parseInt(limit));

      // Update stats
      const totalHours = limited.reduce((sum, a) => sum + (a.ms_played || 0), 0) / 3600000;
      stats.textContent = `${limited.length} álbumes · ${totalHours.toFixed(1)}h`;

      // Render gallery
      container.innerHTML = limited.map(album => {
        const image = album.images?.[1]?.url || album.images?.[0]?.url || '';
        const hours = ((album.ms_played || 0) / 3600000).toFixed(1);
        const spotifyUrl = `https://open.spotify.com/album/${album.id}`;

        return `
          <a href="${spotifyUrl}" target="_blank" rel="noopener" class="album-item" title="${album.name} - ${album.artist_names?.[0] || 'Unknown'}">
            <img src="${image}" alt="${album.name}" loading="lazy">
            <div class="album-overlay">
              <div class="album-name">${album.name}</div>
              <div class="album-artist">${album.artist_names?.[0] || ''}</div>
              <div class="album-time">${hours}h</div>
            </div>
          </a>
        `;
      }).join('');
    }

    // Build collaboration network data
    function buildNetworkData(tracks, artists, minCollabs = 2, topArtists = 50) {
      // Create artist lookup with listening stats
      const artistMap = new Map();
      artists.forEach(a => {
        artistMap.set(a.name, {
          id: a.id,
          name: a.name,
          ms_played: a.ms_played || 0,
          popularity: a.popularity || 0,
          genres: a.genres || [],
          image: a.images?.[2]?.url || a.images?.[1]?.url || a.images?.[0]?.url || null
        });
      });

      // Find collaborations
      const edges = new Map();
      tracks.forEach(track => {
        const trackArtists = track.artist_names || [];
        if (trackArtists.length > 1) {
          // Create edges between all pairs
          for (let i = 0; i < trackArtists.length; i++) {
            for (let j = i + 1; j < trackArtists.length; j++) {
              const a1 = trackArtists[i];
              const a2 = trackArtists[j];
              const key = [a1, a2].sort().join('|||');

              if (!edges.has(key)) {
                edges.set(key, { source: a1, target: a2, weight: 0, tracks: [] });
              }
              edges.get(key).weight += track.ms_played || 0;
              edges.get(key).tracks.push(track.name);
            }
          }
        }
      });

      // Filter edges by minimum collaborations
      const filteredEdges = Array.from(edges.values())
        .filter(e => e.tracks.length >= minCollabs);

      // Get artists involved in filtered edges
      const involvedArtists = new Set();
      filteredEdges.forEach(e => {
        involvedArtists.add(e.source);
        involvedArtists.add(e.target);
      });

      // Get top artists by listening time that are involved in collabs
      const nodes = Array.from(involvedArtists)
        .map(name => artistMap.get(name) || { name, ms_played: 0 })
        .filter(a => a.ms_played > 0)
        .sort((a, b) => b.ms_played - a.ms_played)
        .slice(0, topArtists);

      const nodeNames = new Set(nodes.map(n => n.name));

      // Filter edges to only include nodes in our set
      const finalEdges = filteredEdges.filter(e =>
        nodeNames.has(e.source) && nodeNames.has(e.target)
      );

      return { nodes, edges: finalEdges };
    }

    // Render network graph
    let simulation = null;

    function renderNetworkGraph(tracks, artists, minCollabs = 2, topArtists = 50) {
      const container = document.getElementById('network-container');
      const stats = document.getElementById('network-stats');
      const tooltip = document.getElementById('network-tooltip');

      // Clear previous
      container.querySelectorAll('svg').forEach(s => s.remove());
      if (simulation) simulation.stop();

      const { nodes, edges } = buildNetworkData(tracks, artists, minCollabs, topArtists);

      stats.textContent = `${nodes.length} artistas · ${edges.length} colaboraciones`;

      if (nodes.length === 0) {
        container.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">No hay suficientes colaboraciones con estos filtros</div>';
        return;
      }

      const width = container.clientWidth;
      const height = container.clientHeight || 500;

      // Create SVG
      const svg = d3.select(container)
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, width, height]);

      // Scales
      const maxMs = d3.max(nodes, d => d.ms_played);
      const radiusScale = d3.scaleSqrt()
        .domain([0, maxMs])
        .range([4, 30]);

      // Create defs for image patterns (after radiusScale is defined)
      const defs = svg.append('defs');

      nodes.forEach((d, i) => {
        if (d.image) {
          const r = radiusScale(d.ms_played);
          const diameter = r * 2;
          defs.append('pattern')
            .attr('id', `artist-img-${i}`)
            .attr('width', 1)
            .attr('height', 1)
            .attr('patternContentUnits', 'objectBoundingBox')
            .append('image')
            .attr('href', d.image)
            .attr('width', 1)
            .attr('height', 1)
            .attr('preserveAspectRatio', 'xMidYMid slice');
        }
      });

      const maxEdgeWeight = d3.max(edges, d => d.weight);
      const strokeScale = d3.scaleSqrt()
        .domain([0, maxEdgeWeight])
        .range([1, 8]);

      // Create node map for edge references
      const nodeMap = new Map(nodes.map(n => [n.name, n]));

      // Prepare edges with node references
      const links = edges.map(e => ({
        ...e,
        source: nodeMap.get(e.source),
        target: nodeMap.get(e.target)
      })).filter(e => e.source && e.target);

      // Force simulation
      simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.name).distance(50).strength(1))
        .force('charge', d3.forceManyBody().strength(-100))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('x', d3.forceX(width / 2).strength(0.1))
        .force('y', d3.forceY(height / 2).strength(0.1))
        .force('collision', d3.forceCollide().radius(d => radiusScale(d.ms_played) + 3));

      // Draw links
      const link = svg.append('g')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('class', 'network-link')
        .attr('stroke-width', d => strokeScale(d.weight));

      // Draw nodes
      const node = svg.append('g')
        .selectAll('g')
        .data(nodes)
        .join('g')
        .attr('class', 'network-node')
        .call(d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended));

      // Add index to nodes for pattern reference
      nodes.forEach((d, i) => d.nodeIndex = i);

      node.append('circle')
        .attr('r', d => radiusScale(d.ms_played))
        .attr('fill', d => d.image ? `url(#artist-img-${d.nodeIndex})` : (d.genres?.length > 0 ? '#1a1a1a' : '#737373'))
        .attr('stroke', '#1a1a1a')
        .attr('stroke-width', 2);

      node.append('text')
        .text(d => d.name)
        .attr('dx', d => radiusScale(d.ms_played) + 4)
        .attr('dy', '0.35em');

      // Tooltip and highlighting
      node.on('mouseenter', function(event, d) {
        const hours = (d.ms_played / 3600000).toFixed(1);
        const connectedEdges = links.filter(l => l.source.name === d.name || l.target.name === d.name);
        const collabCount = connectedEdges.length;

        tooltip.innerHTML = `
          <div class="tooltip-title">${d.name}</div>
          <div class="tooltip-detail">${hours}h escuchadas</div>
          <div class="tooltip-detail">${collabCount} colaboraciones</div>
          ${d.genres?.length > 0 ? `<div class="tooltip-detail">${d.genres.slice(0, 2).join(', ')}</div>` : ''}
        `;
        tooltip.classList.add('visible');

        // Highlight connected
        const connectedNames = new Set([d.name]);
        connectedEdges.forEach(e => {
          connectedNames.add(e.source.name);
          connectedNames.add(e.target.name);
        });

        node.classed('highlighted', n => connectedNames.has(n.name));
        link.classed('highlighted', l => l.source.name === d.name || l.target.name === d.name);
      })
      .on('mousemove', function(event) {
        const rect = container.getBoundingClientRect();
        tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
      })
      .on('mouseleave', function() {
        tooltip.classList.remove('visible');
        node.classed('highlighted', false);
        link.classed('highlighted', false);
      });

      // Simulation tick
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        node.attr('transform', d => `translate(${d.x},${d.y})`);
      });

      // Drag functions
      function dragstarted(event) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
      }

      function dragged(event) {
        event.subject.fx = event.x;
        event.subject.fy = event.y;
      }

      function dragended(event) {
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
      }
    }

    // Render scatterplot: Popularity vs Time Listened
    function renderScatterplot(artists, limit = 50) {
      const container = document.getElementById('scatter-container');
      const stats = document.getElementById('scatter-stats');
      const tooltip = document.getElementById('scatter-tooltip');

      // Clear previous
      container.querySelectorAll('svg').forEach(s => s.remove());

      // Filter and sort artists
      const filtered = artists
        .filter(a => a.ms_played > 0 && a.popularity !== undefined)
        .sort((a, b) => b.ms_played - a.ms_played)
        .slice(0, limit);

      // Calculate stats
      const avgPop = filtered.reduce((sum, a) => sum + a.popularity, 0) / filtered.length;
      stats.textContent = `${filtered.length} artistas · Popularidad promedio: ${avgPop.toFixed(0)}`;

      const margin = { top: 30, right: 30, bottom: 50, left: 60 };
      const width = container.clientWidth - margin.left - margin.right;
      const height = (container.clientHeight || 450) - margin.top - margin.bottom;

      // Create SVG
      const svg = d3.select(container)
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      // Scales
      const xScale = d3.scaleLinear()
        .domain([0, 100])
        .range([0, width]);

      const maxHours = d3.max(filtered, d => d.ms_played) / 3600000;
      const yScale = d3.scaleLinear()
        .domain([0, maxHours * 1.1])
        .range([height, 0]);

      const radiusScale = d3.scaleSqrt()
        .domain([0, d3.max(filtered, d => d.ms_played)])
        .range([6, 25]);

      // Create defs for image patterns
      const defs = svg.append('defs');
      filtered.forEach((d, i) => {
        const img = d.images?.[2]?.url || d.images?.[1]?.url || d.images?.[0]?.url;
        if (img) {
          defs.append('pattern')
            .attr('id', `scatter-img-${i}`)
            .attr('width', 1)
            .attr('height', 1)
            .attr('patternContentUnits', 'objectBoundingBox')
            .append('image')
            .attr('href', img)
            .attr('width', 1)
            .attr('height', 1)
            .attr('preserveAspectRatio', 'xMidYMid slice');
        }
      });

      // Add quadrant backgrounds
      const midX = 50; // Popularity midpoint
      const midY = maxHours / 2;

      // Quadrant labels
      g.append('text')
        .attr('class', 'scatter-quadrant-label')
        .attr('x', xScale(25))
        .attr('y', 15)
        .attr('text-anchor', 'middle')
        .text('Underground favoritos');

      g.append('text')
        .attr('class', 'scatter-quadrant-label')
        .attr('x', xScale(75))
        .attr('y', 15)
        .attr('text-anchor', 'middle')
        .text('Mainstream favoritos');

      g.append('text')
        .attr('class', 'scatter-quadrant-label')
        .attr('x', xScale(25))
        .attr('y', height - 5)
        .attr('text-anchor', 'middle')
        .text('Underground ocasional');

      g.append('text')
        .attr('class', 'scatter-quadrant-label')
        .attr('x', xScale(75))
        .attr('y', height - 5)
        .attr('text-anchor', 'middle')
        .text('Mainstream ocasional');

      // Add midlines (vertical for popularity, horizontal for time)
      g.append('line')
        .attr('x1', xScale(50))
        .attr('y1', 0)
        .attr('x2', xScale(50))
        .attr('y2', height)
        .attr('stroke', '#e5e5e5')
        .attr('stroke-dasharray', '4,4');

      g.append('line')
        .attr('x1', 0)
        .attr('y1', yScale(midY))
        .attr('x2', width)
        .attr('y2', yScale(midY))
        .attr('stroke', '#e5e5e5')
        .attr('stroke-dasharray', '4,4');

      // Axes
      const xAxis = d3.axisBottom(xScale)
        .tickValues([0, 25, 50, 75, 100])
        .tickFormat(d => d);

      const yAxis = d3.axisLeft(yScale)
        .ticks(5)
        .tickFormat(d => `${d}h`);

      g.append('g')
        .attr('class', 'scatter-axis')
        .attr('transform', `translate(0,${height})`)
        .call(xAxis);

      g.append('g')
        .attr('class', 'scatter-axis')
        .call(yAxis);

      // Axis labels
      g.append('text')
        .attr('class', 'scatter-axis-label')
        .attr('x', width / 2)
        .attr('y', height + 40)
        .attr('text-anchor', 'middle')
        .text('← Underground · Popularidad en Spotify · Mainstream →');

      g.append('text')
        .attr('class', 'scatter-axis-label')
        .attr('transform', 'rotate(-90)')
        .attr('x', -height / 2)
        .attr('y', -45)
        .attr('text-anchor', 'middle')
        .text('Horas escuchadas');

      // Add index to data
      filtered.forEach((d, i) => d.scatterIndex = i);

      // Draw points
      const points = g.selectAll('.scatter-point')
        .data(filtered)
        .join('circle')
        .attr('class', 'scatter-point')
        .attr('cx', d => xScale(d.popularity))
        .attr('cy', d => yScale(d.ms_played / 3600000))
        .attr('r', d => radiusScale(d.ms_played))
        .attr('fill', d => {
          const img = d.images?.[2]?.url || d.images?.[1]?.url || d.images?.[0]?.url;
          return img ? `url(#scatter-img-${d.scatterIndex})` : '#1a1a1a';
        })
        .attr('stroke', '#1a1a1a')
        .attr('stroke-width', 1.5);

      // Tooltip
      points.on('mouseenter', function(event, d) {
        const hours = (d.ms_played / 3600000).toFixed(1);
        const category = d.popularity < 50 ? 'Underground' : 'Mainstream';

        tooltip.innerHTML = `
          <div class="tooltip-title">${d.name}</div>
          <div class="tooltip-detail">${hours}h escuchadas</div>
          <div class="tooltip-detail">Popularidad: ${d.popularity}/100 (${category})</div>
          ${d.genres?.length > 0 ? `<div class="tooltip-detail">${d.genres.slice(0, 2).join(', ')}</div>` : ''}
        `;
        tooltip.classList.add('visible');
      })
      .on('mousemove', function(event) {
        const rect = container.getBoundingClientRect();
        tooltip.style.left = (event.clientX - rect.left + 10) + 'px';
        tooltip.style.top = (event.clientY - rect.top - 10) + 'px';
      })
      .on('mouseleave', function() {
        tooltip.classList.remove('visible');
      });
    }

    async function init() {
      const data = await loadMetadata();
      albumsData = data.albums.filter(a => a.images?.length > 0 && a.ms_played > 0);

      // Initial render - Album gallery
      renderAlbumGallery(albumsData, 'time', 100);

      // Initial render - Network graph
      renderNetworkGraph(data.tracks, data.artists, 2, 50);

      // Initial render - Scatterplot
      renderScatterplot(data.artists, 50);

      // Setup album gallery controls
      document.getElementById('sort-select').addEventListener('change', (e) => {
        const limit = document.getElementById('limit-select').value;
        renderAlbumGallery(albumsData, e.target.value, limit);
      });

      document.getElementById('limit-select').addEventListener('change', (e) => {
        const sortBy = document.getElementById('sort-select').value;
        renderAlbumGallery(albumsData, sortBy, e.target.value);
      });

      // Setup network controls
      document.getElementById('network-min-collabs').addEventListener('change', (e) => {
        const topArtists = parseInt(document.getElementById('network-top-artists').value);
        renderNetworkGraph(data.tracks, data.artists, parseInt(e.target.value), topArtists);
      });

      document.getElementById('network-top-artists').addEventListener('change', (e) => {
        const minCollabs = parseInt(document.getElementById('network-min-collabs').value);
        renderNetworkGraph(data.tracks, data.artists, minCollabs, parseInt(e.target.value));
      });

      // Setup scatterplot controls
      document.getElementById('scatter-limit').addEventListener('change', (e) => {
        renderScatterplot(data.artists, parseInt(e.target.value));
      });

      // Initial render - Timeline
      renderTimeline(data.albums, 'count');

      // Setup timeline controls
      document.getElementById('timeline-metric').addEventListener('change', (e) => {
        renderTimeline(data.albums, e.target.value);
      });
    }

    // Render timeline histogram
    function renderTimeline(albums, metric = 'count') {
      const container = document.getElementById('timeline-container');
      const stats = document.getElementById('timeline-stats');

      // Clear previous
      container.innerHTML = '';

      // Group albums by year
      const yearData = new Map();
      albums.forEach(album => {
        const releaseDate = album.release_date;
        if (!releaseDate) return;
        const year = parseInt(releaseDate.substring(0, 4));
        if (isNaN(year) || year < 1950 || year > 2025) return;

        if (!yearData.has(year)) {
          yearData.set(year, { count: 0, ms_played: 0 });
        }
        yearData.get(year).count += 1;
        yearData.get(year).ms_played += album.ms_played || 0;
      });

      // Convert to array and fill gaps
      const years = Array.from(yearData.keys()).sort((a, b) => a - b);
      const minYear = Math.min(...years);
      const maxYear = Math.max(...years);

      const data = [];
      for (let y = minYear; y <= maxYear; y++) {
        const d = yearData.get(y) || { count: 0, ms_played: 0 };
        data.push({
          year: y,
          count: d.count,
          hours: d.ms_played / 3600000
        });
      }

      // Stats
      const totalAlbums = albums.filter(a => a.release_date).length;
      const avgYear = years.reduce((sum, y) => sum + y * (yearData.get(y)?.count || 0), 0) / totalAlbums;
      const peakYear = data.reduce((max, d) => (metric === 'count' ? d.count : d.hours) > (metric === 'count' ? max.count : max.hours) ? d : max, data[0]);
      stats.textContent = `${totalAlbums} álbumes · Promedio: ${avgYear.toFixed(0)} · Pico: ${peakYear.year}`;

      // Dimensions
      const margin = { top: 20, right: 20, bottom: 40, left: 50 };
      const width = container.clientWidth - margin.left - margin.right;
      const height = (container.clientHeight || 300) - margin.top - margin.bottom;

      // Create SVG
      const svg = d3.select(container)
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom);

      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      // Scales
      const xScale = d3.scaleBand()
        .domain(data.map(d => d.year))
        .range([0, width])
        .padding(0.1);

      const yValue = d => metric === 'count' ? d.count : d.hours;
      const maxY = d3.max(data, yValue);
      const yScale = d3.scaleLinear()
        .domain([0, maxY * 1.1])
        .range([height, 0]);

      // Find key decades for visual interest
      const decades = [1970, 1980, 1990, 2000, 2010, 2020];
      decades.forEach(decade => {
        if (decade >= minYear && decade <= maxYear) {
          g.append('line')
            .attr('x1', xScale(decade))
            .attr('y1', 0)
            .attr('x2', xScale(decade))
            .attr('y2', height)
            .attr('stroke', '#f0f0f0')
            .attr('stroke-width', 1);
        }
      });

      // Bars
      const bars = g.selectAll('.bar')
        .data(data)
        .join('rect')
        .attr('class', 'bar')
        .attr('x', d => xScale(d.year))
        .attr('y', d => yScale(yValue(d)))
        .attr('width', xScale.bandwidth())
        .attr('height', d => height - yScale(yValue(d)))
        .attr('fill', d => {
          // Color by era
          if (d.year >= 2020) return '#1a1a1a';
          if (d.year >= 2010) return '#404040';
          if (d.year >= 2000) return '#595959';
          if (d.year >= 1990) return '#737373';
          return '#a3a3a3';
        })
        .style('cursor', 'pointer');

      // Tooltip
      const tooltip = d3.select(container)
        .append('div')
        .style('position', 'absolute')
        .style('background', '#1a1a1a')
        .style('color', 'white')
        .style('padding', '0.5rem 0.75rem')
        .style('font-size', '0.75rem')
        .style('pointer-events', 'none')
        .style('opacity', 0)
        .style('z-index', 10);

      bars.on('mouseenter', function(event, d) {
        tooltip.html(`
          <strong>${d.year}</strong><br>
          ${d.count} álbumes<br>
          ${d.hours.toFixed(1)}h escuchadas
        `)
        .style('opacity', 1);
        d3.select(this).attr('fill', '#000');
      })
      .on('mousemove', function(event) {
        const rect = container.getBoundingClientRect();
        tooltip
          .style('left', (event.clientX - rect.left + 10) + 'px')
          .style('top', (event.clientY - rect.top - 10) + 'px');
      })
      .on('mouseleave', function(event, d) {
        tooltip.style('opacity', 0);
        d3.select(this).attr('fill', () => {
          if (d.year >= 2020) return '#1a1a1a';
          if (d.year >= 2010) return '#404040';
          if (d.year >= 2000) return '#595959';
          if (d.year >= 1990) return '#737373';
          return '#a3a3a3';
        });
      });

      // X axis - show only decades
      const xAxis = d3.axisBottom(xScale)
        .tickValues(data.filter(d => d.year % 10 === 0).map(d => d.year))
        .tickFormat(d => d);

      g.append('g')
        .attr('class', 'scatter-axis')
        .attr('transform', `translate(0,${height})`)
        .call(xAxis);

      // Y axis
      const yAxis = d3.axisLeft(yScale)
        .ticks(5)
        .tickFormat(d => metric === 'count' ? d : `${d}h`);

      g.append('g')
        .attr('class', 'scatter-axis')
        .call(yAxis);

      // Y axis label
      g.append('text')
        .attr('class', 'scatter-axis-label')
        .attr('transform', 'rotate(-90)')
        .attr('x', -height / 2)
        .attr('y', -35)
        .attr('text-anchor', 'middle')
        .text(metric === 'count' ? 'Álbumes' : 'Horas escuchadas');
    }

    init();
  </script>
</body>
</html>
